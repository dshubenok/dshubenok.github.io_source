Выбор в качестве основного ORM, всякие сложные запросы, echo=True с исследованием того, что происходит. Постоянно держит в голове, что ORM лишь обертка и смотрит на то, какие запросы она генерит.

Что почитать:

Jason Myers, Rick Copeland, **Essential SQLAlchemy, 2nd edition, 2016**

[]()

# Введение

Пришло время добавить в приложение реальные данные. FastAPI позволяет работать с любой базой данных, как напрямую, так и с использованием ORM. В этой теме вы начнете знакомиться с самой популярной ORM-библиотекой — SQLAlchemy: настроите подключение к базе данных, опишете данные в виде классов и научитесь выполнять CRUD-операции с ними.

Для начала установите SQLAlchemy, предварительно убедившись, что вы находитесь в виртуальном окружении:

    pip install sqlalchemy
    

Создайте директорию `data` со следующей структурой:

    app
    ├── data
    │   ├── __init__.py
    │   ├── database.py
    │   ├── models.py
    │   ├── schemas.py
    │   ├── crud.py
    

Файл `__init__.py` нужен для того, чтобы объявить директорию `data` пакетом, а все вложенные в неё файлы — модулями.

Файл `database.py` будет отвечать за инициацию работу с базой данных. Код, который здесь находится, содержит базовые настройки и обычно не меняется. Здесь вы указываете, к какой базе данных нужно подключиться, делаете все необходимые импорты и фиксируете необходимые настройки.

`[models.py](http://models.py/)` нужен для описания моделей данных — в нем вы описываете таблицы базы данных в виде классов.

В файле `crud.py` вы напишете функции для работы с базой данных — функции для создания, чтения, изменения или удаления данных.

**Оформляем файл `data/database.py`**

Начнем с создания файла настроек.

Создайте подключение к базе данных и присвойте его переменной engine (англ. "engine" - двигатель, мотор). Для этого используется функция create_engine() из пакета sqlalchemy. В качестве аргумента функции нужно передать описание базы данных: `sqlite:///yam.db`

    from sqlalchemy import create_engine
    
    engine = create_engine('sqlite:///yam.db')
    

Функция create_engine() создает экземпляр класса Engine и описывает диалект базы данных, в нашем случае все команды будет обрабатывать

> Если передать функции create_engine необязательный параметр echo=True, то вы сможете видеть результат выполнения всех обращений к базе данных в реальном времени в командной строке.

Подключение настроено, теперь вам нужен интерфейс для работы с базой данных. Для этого необходимо создать класс `Session` с помощью функции `sessionmaker` из пакета `sqlalchemy.orm` и связать его с объектом `engine`, то есть передать в качестве аргумента в параметр `bind` наш созданный ранее `engine:`

    from sqlalchemy.orm import sessionmaker
    
    Session = sessionmaker(bind=engine)
    

Сессия — это инструмент работы с базой данных, о ней мы подробно поговорим в следующем уроке.

# Модели

## Learning outcomes

Это будет самый объемный и сложный блок курса.

Студент научится архитектурно правильно добавлять алхимию в проект.

Узнает, в чем разница между уже изученным Django ORM и почему Алхимия выигрывает.

Опишет модели и CRUD-операции для работы с ними.

Чтобы начать работать с данными, необходимо рассказать SQLAlchemy о наших таблицах, то есть описать их в виде классов, наследуясь от базового класса **Base**, который мы проимпортировали в файле [database.py](http://database.py/).

> SQLAlchemy поддерживает два способа описания таблиц — классический и декларативный. Второй способ почти всегда предпочтительней и удобнее, его мы и будем рассматривать. Про отличия двух способов можно почитать здесь: https://docs.sqlalchemy.org/en/13/orm/mapping_styles.html#classical-mappings

Откройте в редакторе кода файл `data/models.py`

Проимпортируйте базовый класс `Base` из модуля [database.py](http://database.py/) и создайте классы таблиц, наследуясь от класса `Base`. Имя класса будет соответствовать таблице в базе данных. Укажите `__tablename__` — это необязательный параметр, но он нужен для удобства:

    from .database import Base
    
    
    class Review(Base):
        __tablename__ = "reviews"
    

Теперь опишите атрибуты классов, которые будут столбцами в этих таблицах. Названия атрибутов будут соответствовать названиям столбцов. В качестве значения по умолчанию для атрибута присваиваем `Column` из библиотеки `sqlalchemy` и передаем в качестве аргумента тип столбца и другие необязательные параметры.

    from .database import Base
    
    
    class Review(Base):
        __tablename__ = "reviews"
    
        id = Column(Integer, primary_key=True, index=True)
        title = Column(String, index=True)
        text = Column(String, index=True)
    

Опишите отношения между таблицами. Для этого проимпортируйте `relationship` из `sqlalchemy.orm`

# Запросы

За работу с базой данных отвечает объект **session**.

Сессию можно представлять себе как контейнер, в который вы добавляете какие-то объекты, которые хотите записать в базу. Делается это с помощью метода **add**: `session.add`

Вы можете посмотреть, какие объекты находятся в этом контейнере с помощью метода **new**: `session.new`

Наконец, чтобы отправить контейнер с объектами для записи в базу данных, вызывается метод `session.commit`

У сессии есть метод query.

# CRUD

Откройте файл `data/crud.py`

В этом файле необходимо описать функции для операций с данными в базе данных.

Вы уже умеете делать запросы, вызывая метод .query у объекта session и фильтровать результаты с помощью метода .filter . Всё, что осталось сделать — упаковать эти вызовы в функции:

    def get_author(db: Session, author_id: int):
        return db.query(models.Author).filter(models.Author.id == author_id).first()
    

*Функция, возвращающая объект автора отзыва по его **id**.*

    def create_author(db: Session, author: schemas.AuthorCreate):
        db_author = models.Author(email=author.email)
        db.add(db_author)
        db.commit()
        db.refresh(db_author)
        return db_author
    

*Функция, записывающая в базу данных нового автора.*

- Задание 1

    Опишите функцию get_authors, которая возвращает список объектов авторов.

# Схемы

Про Type Hints сначала.

Всегда нужно проводить проверку данных перед тем, как записывать их в базу данных. Проверка данных (или валидация) может выполняться разными способами.

Если данные не проходят проверку, то возвращается ответ с указанием.

# Миграции

## Learning outcomes

Alembic — это инструмент для миграций Алхимии. Студент научится работать с этим инструментом и делать миграции правильно. В Джанго все делалось двумя командами, здесь же всё несколько сложнее.

Миграции — это система контроля версий для базы данных.

Представьте ситуацию: вы создали базу данных, начали с ней работать, записывать в неё, а потом вдруг осознали, что в таблице не хватает ещё одного обязательного поля. Казалось бы, можно просто добавить это поле, но как быть с уже имеющимися данными? Новое поле должно быть обязательным, поэтому мы должны чем-то заполнить "пропуски".

Для этого существует механизм миграций. Вы уже сталкивались с ним в предыдущем курсе, когда создавали таблицы через Django ORM.

Для этого существует инструмент **Alembic**.

# Параметры запросов

## Learning outcomes

Студент реализует (напишет код) возможность производить манипуляции с данными: фильтровать (с помощью алхимии), сортировать, искать по ключевым словам, устанавливать лимит (например, "выдать только 100 перых записей"), пагинация и так далее. И передавать это в виде параметров запросов.

# Документирование

[https://developer.github.com/v3/](https://developer.github.com/v3/)

Как пример очень хорошей документации.

[http://www.writethedocs.org/guide/writing/beginners-guide-to-docs/](http://www.writethedocs.org/guide/writing/beginners-guide-to-docs/)

Как писать документацию.

# Тестирование

да. будет.